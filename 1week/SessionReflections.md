

# 1주차 회고

[f-lab 멘토링 1주차 질문에 대한 결론.pdf](https://github.com/chanHyeoks-kingdom/f-lab-history/files/13843206/f-lab.1.pdf)
```
이번주는 3가지 질문에 대한 답을 찾는 과정이었다.
(1) 객체지향 프로그래밍이란? (2) 추상화/상속/다형성/캡슐화 (3) 자바의 컴파일 과정

멘토링을 통해 얻은 인사이트를 아래와 같은 목차로 정리해보려한다.
(내 생각을 통해 2차적으로 가공된 결론이어서 멘토링 내용과 연관성이 없을 수 있습니다.)
```

```
# IDX
1. 객체지향 프로그래밍을 하는 이유
2. 좋은 객체지향 설계를 위한 사고와 연습방법
3. 추상화, 상속, 캡슐화 적용에 대한 개발 원칙
4. 잘 쓰여진 코드란? 코드를 잘 쓰려면?
5. Abstract vs Interface
6. JVM의 역할
7. JVM 최적화와 성능적 한계
8. 자바 Execution과정 및 Interpreter / JIT Compiler의 역할
```

<br>

----------------------------------------------

## 1. 객체지향 프로그래밍을 하는 이유

```
객체지향이 이렇게 인기를 얻은 강력한 이유는 '현실 세계의 문제를 IT 레벨로 옮기는데 이만한게 없다'라는 사실 때문이다. 객체지향
이전에 시류였던 절차지향 방식은 '어떻게 구현할까'에 대한 고민의 결과일뿐 '어떻게 코드들을 이해하기 쉬운 상태로 유지할까?'에 대
한 고민의 결과는 아니였다.
```

#### "대부분의 소프트웨어는 필연적으로 변경되는데 만약 서비스가 복잡해져 이해하기 어려운 상태가 된다면 소프트웨어는 지속적으로 변경될 수 없다."

![image](https://github.com/chanHyeoks-kingdom/f-lab-history/assets/68278903/3e6df0d9-4759-4dea-aa2e-7f4492db8451)


<br>

```
이러한 이유로 우리는 "복잡한 비즈니스 로직을 보다 쉽게 이해할 수 있는 새로운 프로그래밍 패러다임이 필요했고 이런 니즈 위에서
'시뮬라'라는 언어를 통해 객체지향은 세상에 처음 등장했다.
```
<br>

## 2. 좋은 객체지향 설계를 위한 사고와 연습방법

```
좋은 객체지향 설계를 위한 사고란 무엇일까? 사실 아직도 어릿한 감이 없지 않지만 한가지는 명확해졌다.
```

####  "객체지향은 복잡한 시스템을 이해하기 쉬운 형태로 만들기 위해서 써야 한다."

<br>

```
이번 주 과제를 진행하며 얻은 나의 첫 번째 철학이다. 이 철학 위에 '그럼 좋은 객체지향 설계를 위한 사고는 무엇인가' 라는 질문을
얹어보면 아래와 같다.
```
##### 1. 객체지향의 본연의 목적은 '복잡한 시스템을 이해하기 쉬운 형태로 유지'하는 것
##### 2. 이런 목적을 위배하지 않는다는 전제 위에서 현실세계의 문제를 '객체들의 상호작용'을 통해 해결하는 것

<br>

##### 그래서 결론은 ..

### 객체지향 설계를 이용해 '시스템의 복잡성을 해소'라는 본연의 목적을 오롯이 완수했을 때 
### 나는 그것이 '좋은 객체지향 설계를 위한 사고'라고 생각한다.


![image](https://github.com/chanHyeoks-kingdom/f-lab-history/assets/68278903/430f3389-c472-497c-8db8-9ce0e62dcf5b)


```
Q. 뭐가 쓸데없이 장황한 감이 있어서 쑥쓰럽긴한디.. 어쨌든 그래서 뭐 어떻게 연습한다는겨 ?
A. 뭐 그냥 디자인 패턴이니, DDD니 객체지향 관련한 뭔가 할 때 저 사고 위에서 하면 될 거 같은디 아직은 잘 모르것네 ..
```


<br>

## 3. 추상화, 상속, 캡슐화 적용에 대한 개발 원칙
```
결국 객체지향 설계를 한다는 건 '객체지향의 원칙'을 적용한다는 걸 의미한다. 그렇다면 어느정도 수준까지 적용해야할까?
```

####  "요로결석 환자한테는 시금치가 독이될 수 있다."

```
뽀빠이의 힘의 원천인 시금치 조차도 사람에 따라 독이 될 수 있듯이 객체지향도 마찬가지다. 추상화, 상속, 캡슐화 모두 객
체지향에 있어서 굉장히 중요한 원칙이지만 어떻게 적용하냐에 따라 전혀 다른 결과를 가져올 수 있다.

.. 생각해보자.
```

<br>

> a. 캡슐화를 적용할 때 사용할 수 있는 원칙들
>
>> 1. 메서드는 무조건 private로 정의하고 필요에 의해 public으로 변경해나간다.
>> 2. 메서드는 무조건 public으로 정의하고 분석 과정을 통해 private으로 
>> 3. 코드를 작성하는 시점에 상황을 보고 그때 그때 결정한다.

```
1. 메서드는 무조건 private로 정의하고 필요에 의해 public으로 변경해나간다.
  - Advantages: 실수로 인해 발생할 수 있는 pulbic에 의한 노출 가능성을 줄일 수 있다.
  - Disadvantages: 개발과 유지보수를 할 때의 복잡성이 증가한다.

2. 메서드는 무조건 public으로 정의하고 분석 과정을 통해 private으로 
  - Advantages: 유연하게 사용할 수 있다.
  - Disadvantages: 객체의 캡슐화를 보장하지 못할 가능성이 커진다.

3. 코드를 작성하는 시점에 상황을 보고 그때 그때 결정한다.
  - Advantages: 개발자들의 주관을 존중할 수 있다.
  - Disadvantages: 개발자의 주관에 맡기는 것이기 때문에 일관성이 없어질 수 있다.

```

<br>

> b. 추상화를 적용할 때 사용할 수 있는 원칙들
>
>> 1. 요구사항을 해결하는 과정에서 추상화가 당장 필요 없더라도 미래를 고려해 적용한다.
>> 2. 요구사항을 해결하는 과정에서 추상화가 당장 필요 없으면 하지 않는다.
```
1. 요구사항을 해결하는 과정에서 추상화가 당장 필요 없더라도 미래를 고려해 적용한다.
  - Advantages: 미래를 정확히 예측한다면 확장성이라는 보상을 받을 수 있다.
  - Disadvantages(1): 확장이 필요하지 않게 될 경우 의미 없이 시스템 복잡성만 늘리게 된다. 일종의 도박이다.
  - Disadvantages(2): 잘못된 추상화를 할 수 있다.
  - Disadvantages(3): 상속의 깊이가 깊어지면 시스템의 복잡성이 급격히 높아질 수 있다.

2. 요구사항을 해결하는 과정에서 추상화가 당장 필요 없으면 하지 않는다.
  - Advantages: 해결해야 할 문제에만 집중할 수 있다.
  - Disadvantages(1): 추상화가 필요해졌을 때 기존 클래스 설계를 변경해야할 수도 있다.
  - Disadvantages(2): 애초에 추상화를 포기하고 별도의 클래스로 개발하게 될 수도 있다.

```


<br>


## 4. 잘 쓰여진 코드란? 코드를 잘 쓰려면?
```
잘 쓰여진 코드는 '나 스스로의 원칙에 위배되지 않는 일관성 있는 코드'이다.
```






<br><br><br><br>

---------


4. 잘 쓰여진 코드란? 코드를 잘 쓰려면?
5. Abstract vs Interface
6. JVM의 역할
7. JVM 최적화와 성능적 한계
8. 자바 Execution과정 및 Interpreter / JIT Compiler의 역할
```

