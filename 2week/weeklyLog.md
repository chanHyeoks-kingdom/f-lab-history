# WEEK 2

```
[이 주의 과제]
1. JVM 메모리 구조에 대해 설명 하시오 (키워드: Method Area, Heap, Stack, etc)
2. 자바 Garbage Collector 동작원리와 과정에 대해 설명 하시오 (키워드: Heap Memory, Minor/Major GC, GC algorithm, etc)
3. Thread Safety와 동기화(synchronization)에 대해 설명 하시오 (키워드: lock, synchronized, deadlock, ThreadLocal, etc)
4. Static, Final 키워드에 대해 설명 하시오 (키워드: 사용이유, 장단점, etc)
```

-----


## [경계성 질문]

## 질문 1.JVM 메모리 구조에 대해 설명 하시오 (키워드: Method Area, Heap, Stack, etc)
```
JVM은 메모리의 효율성과 안정성등의 이점을 이점을 위해 내부적으로 가상의 메모리 공간을 분리하는데요 이런 영역은 '공유되는 영역'과 '공유되지 않는 영역'으로 나뉘는데 혹시 어떤 것 부터 설명드리면 될까요?
```

##### 질문 1-1. 공유되지 않는 녀석들부터 알려주세요
```
네! 공유되지 않는 메모리 영역들은 스택, PC, 네이티브 메소드 스택 영역들이 있습니다. 이 세가지 영역은 쓰레드별로 할당되는 녀석들인데요 스택 영역부터 설명드리면
스택은 결국 스택 프레임이란 걸 후입선출(LIFO)구조로 쌓는 녀석인데요 이 스택 프레임이란 건 결국 메서드 호출 정보고, 저희가 메서드를 호출할 땐 최근에 호출된 녀석을 먼저 실행하기 때문에 스택을 사용합니다.
PC영역의 경우는 사실 Stack으로 메서드 콜을 관리 하는 일도 결국 운영체제의 관리를 받는 JVM이라는 프로세스에서 파생된 스레드를 쓰는거라 이 작업이 완료될때까지 작업을 하는게 아니라 중간에 cpu를 다른 프
로세스한테 뺏겼다가 또 다시 하던곳부터 작업하고의 반복이기 때문에 '내가 어디까지 작업했지?'에 대한 정보를 기록해야 합니다. 그래서 '프로그램 카운터'라는 영역을 두고 거기서 내가 작업한 곳을 기록합니다.

네이티브 메소드 스택은 메서드에서 native 키워드를 통해 c언어로 구현된 네이티브 코드를 실행했을 때 메소드의 흐름과 같이 스택으로 저장됩니다. 이는 JNI라는 인터페이스를 참조해서 네이티브 메서드 라이브러리
라는 영역에서 해당 메서드를 호출합니다.

```

##### 질문 1-2. 공유되는 녀석들은 어떤게 있어요?
```
Method 영역은 정적 정보들을 저장하는 곳입니다. 클래스 로더로 긁어온 클래스의 메타 정보들이나 static,final 키워드 등이 적용된 정적 정보들을 이 method 영역에 저장해줍니다.
Heap 영역은 동적 정보들을 저장하는 곳, 그러니까 객체나 배열 생성시에 이와 관련된 값들이 저장되는 곳이며 GC의 영향을 받습니다.

이 두 영역은 JVM당 하나씩 존재하고 모든 쓰레드에 의해 공유됩니다.
```

<br>



## 질문 2. 자바 Garbage Collector 동작원리와 과정에 대해 설명 하시오 (키워드: Heap Memory, Minor/Major GC, GC algorithm, etc)
```
가비지 컬렉터는 JVM의 시스템 스레드로 실행되는 '객체를 회수하는 프로그램' 입니다. 이 녀석은 계속 Heap 영역을 주시하면서 현재 스레드의 stack과 '연결이 끊어진' 객체들을 청소하는데
제임슨 고슬링 팀은 사람들이 쓰는 객체 대부분이 오래 남아있지 않는다는 사실을 깨닫고, 이를 이용해 청소 효율을 높이기 위해 생성된지 얼마 안된 객체를 처리하는 MinorGc와 오래된 객체를
처리하는 Major GC로 나눴는데 이중에 어떤 것 부터 설명드리면 좋을까요?
```

##### 질문 2-1.거 참.. 궁금한게 많네, MinorGC부터 말해보쇼!
```
저희가 객체나 배열을 생성할 때 이 정보들은 Heap영역으로 넘어가는데 이 때 GC의 Eden 영역에 해당 정보를 저장합니다. 이렇게 신규 객체들이 많아져서 Eden 영역이 꽉 차게 되면 MinorGC
라는 걸 하게 되는데 이 때 Eden 영역에서 살아남은 객체, 해당 쓰레드의 즉 Stack 영역과의 연결이 끊어지지 않은 객체들만 survivor 영역으로 이동합니다. survivor 영역 안에서도 1, 2
로 나뉘어 mark and sweep이라는 알고리즘으로 제거 작업이 일어나는데 간단히 말하면 그냥 제거할 놈 제거하고 남은 메모리 단편화 제거하기 위해 반대편 survivor에 순차적으로 값을 넣어주는
것 입니다. 어쨌든 이런 Eden과 Survivor 영역을 'Young Generation'이라고 하고 이 안에서 Minor GC가 일어납니다!
```

##### 질문 2-2. Major GC도 설명 해봐요~
```
MinorGC에서 Survivor 영역을 왔다갔다 할 때 마다 AgeCount 혹은 Generation Count라는게 계속 증가하는데 일정 수치가 넘어간 객체들은 Old 영역으로 넘어갑니다. (이건 minor GC의 결과)
그렇게 Old영역으로 넘어가는 객체들이 많아지고 결국 꽉 차게 되면, MajorGC 혹은 FullGC라고 불리는 GC가 발생하게 됩니다. 이 때 STW라고 해서 
```

<br>


## 질문 3.Thread Safety와 동기화(synchronization)에 대해 설명 하시오 (키워드: lock, synchronized, deadlock, ThreadLocal, etc)
```
그러게 .. 쓰레드는 동기화 잘 해줘야 한다고 하는 거 같은디, 그 중에 방법이 저 synchronized였던게 기억이 나네 그려 ..

```

##### 질문 3-1.각 영역이 하는 일이 뭔데요?
```

```

<br>


## 질문 4.Static, Final 키워드에 대해 설명 하시오 (키워드: 사용이유, 장단점, etc)
```
Static 쓰면 method 영역에 들어갈거야? 근데 클래스도 마찬가지 아녀? 클래스 필드도 결국 그냥 method 갔더 거 같은디 .

```

##### 질문 4-1.각 영역이 하는 일이 뭔데요?
```

```

<br>


[그냥 연습장]
------
JVM(프로세스)
- 메인 쓰레드
- JVM용 쓰레드
- 가비지 컬렉터용 쓰레드
  
이렇게 될거야


