# 3주차 회고

[3주차 멘토링 질문에 대한 내 답변.pdf](-)
```
이번주는 4가지 질문에 대한 답을 찾는 과정이었다.
1. Thread Safety와 동기화(synchronization)에 대해 설명 하시오 (키워드: lock, synchronized, deadlock, ThreadLocal, etc)
2. Static, Final 키워드에 대해 설명 하시오 (키워드: 사용이유, 장단점, etc)
3. Java 예외처리에 대해 설명하세요 (keyword: error, checked/unchecked exception, try/catch/finally, throws/throw)
4. Java Generic에 대해 설명 하시오 (keyword: 타입 파라미터, wildcard, type erasure, 장/단점, etc)

멘토링을 통해 얻은 인사이트를 아래와 같은 목차로 정리해보려한다.
(내 생각을 통해 2차적으로 가공된 결론이어서 멘토링 내용과 연관성이 없을 수 있습니다.)
```

> [@고민해볼 관점]
> 
> (1) Deadlock이 발생하는 상황들과 방지법
> (2) 동기화 문제 종류 및 발견 방법과 방지하는 법, 실제 코딩 작성시 고려 사항
> (3) Static 키워드 사용시 주의점, 메모리 누수
> (4) Final 키워드 선택 원칙
> (5) Catch block, custom exception과 throws/throw 사용에 대한 원칙
----------------------------------------------

<br>

## 1. 자바에서 Thread Safety와 동기화를 어떻게 준수할까요?


```
먼저 `thread safety`라는 건 여러 스레드를 이용해 병렬 작업을 수행할 때 작업의 결과로 데이터 정합성이 헤쳐지지 않는 상태를 유지하는 것을 말합니다. 여러 스레드를 동시에 사용할 때
우리는 '레이스 컨디션'같은 상황등을 통해 데이터 정합성을 보장하지 못할 수 있는데 대표적으로 lock을 이용해 공유 자원에 대한 동시접근을 컨트롤해 이 문제를 해결할 수 있습니다. 사실 동
기화 문제라는 건 비단 레이스 컨디션 같은 문제 뿐 아니라 이를 해결하기 위해 락이란 걸 적용했을 때 발생하는 데드락, 스타베이션 이라던지 잘못된 애플리케이션 설계로 인해 발생할 수 있는
라이브락 등의 문제들을 총칭하는 개념입니다. 이런 멀티 스레드 환경에서 발생할 수 있는 문제들을 사전에 잘 조율하는 것을 동기화 라고 합니다.

특히 자바에서는 이런 동기화를 위해 synchronized라는 키워드를 제공합니다.
```

> 이런 식으로 lock을 사용해 부분적 직렬화를 적용하게 되면 Deadlock과 같은 상황에 노출될 수 있게된다. 이를 해결하기 위한 방법중 `사전 할당을 통한 순차적 락 점유` 방식을 통해 문제를 해결했다.
[[관련 내용]](https://blog.naver.com/cksgurwkd12/223336505526)

<br>

## 2. 동기화 문제 종류 및 발견 방법과 방지하는 법, 실제 코딩 작성시 고려 사항


```
동기화 문제란건 '멀티 스레드 환경에서 일어날 수 있는 모든 문제'를 의미하며 단순히 나열하면 '데드락', '라이브락', '스타베이션', '레이스 컨디션' 등이 있다. 이를 방지하는 방법은 락을 순차적으로 사용한다거나 순환참조
를 하지 않는다거나 애초에 락을 사용치 않으면서 레이스 컨디션을 일으키지 않도록 불변객체등을 사용하는 방법등이 있다. 사실 클래스를 작성하는 순간부터 내 클래스를 사용하는 사람이 어떤 환경, 그러니까 단일 프로세스나 멀티
스레드에서 사용할지 확신할 수 없기 때문에 당장 요구사항에 멀티 스레드 환경을 고려치 않더라도 이를 염두해 둬야한다. 다만 동시성 이슈에 대한 해결은 성능과 트레이드 오프인 경우가 많아서 이런 부분을 고려해 의사결정토록 하
는것이 좋을 거 같다.
```

<br>


## 3. Final과 static에 대해서


```
먼저 static은 클래스 레벨에 변수나 메서드를 인스턴스가 아닌 클래스 자체에 속하게 만드는 것을 의미하는데, 모든 인스턴스와 스레드에서 접근 가능하게 되다보니 동시성 이슈나 메모리 문제를 야기할 수
있습니다. 그래서 신중하게 사용되어야 하고 이 중에서 동시성 문제를 해결키 위해 불변 상태로 만드는 final 등을 사용합니다. 특정 final 원칙의 경우 모든 인자로 넘어가는 변수에 대해 final을 무조건
붙이는 것을 주장하는 녀석들도 있는데 물론 스레드 안전성이나 컴파일 시점의 최적화, 휴먼 에러 같은 이점을 가져올 순 있지만 코드의 유연성을 헤칠 수 있는 부분은 자명해보인다. 일단 한동안 코드를 쓸 때
저런 방식을 사용해보면서 실제 어떤 문제가 있는지 몸으로 이해해보기로 마무리 지었다.
```

<br>

## 4. Java Generic에 대해 설명 하시오 (keyword: 타입 파라미터, wildcard, type erasure, 장/단점, etc)

```
자바 제네릭은 타입 파라미터나 와일드 카드라는걸 통해 동적으로 타입을 받을 수 있도록 도와주고 그 안에서 타입 안전성을 보장해주는 역할을 하는 개념이다. 보다 직관적인 방법으로 Object를 통해 여러
여러 타입을 하나의 클래스나 메서드에서 입력받을 수 있는데 이 경우 사용할 때마다 사용자가 해당 요소의 타입을 체크한 다음 캐스팅해줘야 하는 번거로움이 있고 이 과정에서 휴먼 에러가 발생할 가능성이
높다. 그래서 제네릭은 타입 파라미터나 와일드 카드를 통해 이런 것들을 유연하게 관리해주는 역할을 한다. 그리고 타입 파라미터나 와일드카드로 지정된 타입들은 별도의 상한, 하한 구분이 없으면 Object로
컴파일 시점에 변경된다. 결론은 타입 유연성을 위해 사람이 해야했던 번거로운 작업들을 컴파일 시점에서 대신해주는게 제네릭이다.
```

<br>

## 5. java exception에 대해서

```
자바 exception은 '예상치 못한 상황'을 안전하게 관리하기 위해 자바에서 제공하는 기능이다. 자바에선 이런 예상치 못한 상황을 크게 '에러'와 '예외'로 나누는데 에러의 경우 핸들링을 하기가 어려울 정도로
큰 문제들에 대해 단순히 '기록'하는 정도를 목적으로 제공한다. 예컨대 OOME(OutOfMemoryException)이나 StackOverflow등이 여기에 속한다. 반면 예외는 우리가 핸들링할법한 것들을 다루는데 이것도
크게 2가지로 나뉜다. 바로 runtime 환경에서 일어나는 uncheckedException과 컴파일 시점에서 미리 확인할 수 있는 checkedException이다.
```

> uncheckedException은 그 유명한 nullPointException이나 ArrayIndexOutOfBounds가 있다. 이런 익셉션은 어차피 컴파일 수준에서 체크하지 않기 때문에 try, catch로 처리하지 않더라도 최상위
>
> 메서드로 올라가 처리된다. 반면 checkedException은 무조건 try, catch나 throws를 통해 해당 메서드에서 핸들링 할건지 상위 메서드에 핸들링 책임을 넘길건지 지정할 수 있다. 사실 이렇게 보면 runtime
>
> Exception, 그러니까 uncheckedException에 대해선 핸들링 하지 못하는 것 처럼 보일 수 있는데 해당 익셉션이 발생할만한 지점에 throw를 키워드를 사용해 직접 에러를 던질 수 있다. 이 과정에서 좀 더
>
> 우리의 용도를 좀 더 명확히 표현하기 위해 기존 exception을 상속받아 customException을 만들어 처리할 수도 있는데 이러한 내용은 클라이언트의 요구사항이나 팀의 컨벤션등을 고려해 이루어지는게 좋다.

<br>

--- 
