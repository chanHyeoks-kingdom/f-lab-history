

# WEEK 7

```
[이 주의 과제]
1. 디자인 패턴 중 3가지 선택- 예: 싱글톤, 팩토리, 어댑터 (디자인 패턴 사용 이유, 예제, 조심해야 할 점)
2. 스프링의 IoC(Inversion of Control)과 DI(Dependency Injection)에 대해 설명하시오
3. 스프링 빈 주입 방법에 대해 설명하시오
4. Spring AOP(Aspect-Oriented Programming)에 대해 설명하시오
5. Git Branch 전략에 대해 설명하시오 (eg. git flow, github flow, etc)
```



## [자문자답]


----------


### 1. 디자인 패턴 중 3가지 선택- 예: 싱글톤, 팩토리, 어댑터 (디자인 패턴 사용 이유, 예제, 조심해야 할 점)

#### (1) [Factory Pattern]
> ##### `입력에 따라 생성해야 하는 객체들이 다를 때` 더 잘 관리하기 위해 사용하는 패턴입니다. 객체들을 생성하는 팩토리라는 클래스를 이용해 `각 팩토리에 맞는 객체 생성을 돕는 메서드를 제공`하는 것입니다. 실제 코드는 [여기](https://github.com/choichanhyeok/just-java-note/tree/master/src/main/java/org/example/designPattern/factory/case2AboutDao)에 작성해뒀습니다.
```
아래 코드 비교를 통해서 확인할 수 있는 장점은 아래와 같습니다.

a. 중복 코드를 줄였습니다. 분기에 따른 객체 생성량이 많아질수록 중복 코드를 줄이게 됩니다.
b. OCP를 준수할 수 있게 됩니다. 만약에 저 test thread에서 사용하는 객체를 다른 버전으로 변경해야할 일이 생기더라도 팩토리 내부에서 해당 객체를 수정해주면 됩니다. 이는 의존성 분리와 코드 유지보수성 향상의 이점을 얻을 수 있다고 보입니다.
```
```
아래 코드 비교를 통해서 확인할 수 있는 단점은 아래와 같습니다.

a. 결국 관계성이라는게 생겨서 저 dao의 실제 구현체를 확인하고 싶은 사람들은 팩토리를 거쳐 dao클래스를 찾아 가야 합니다.
b. 결국 팩토리 패턴은 추가적인 추상화 계층을 더하고 관계성을 추가하는거여서 초기 구현 과정을 복잡하게 만들 수 있습니다. 그리고 클라이언트에서 이를 관리해야 하는 경우라면 유지보수성에 악영향을 줄 수 있습니다.
c. dao를 하나 더 추가해 저 test thread에 관련 기능을 추가하고 싶다고 할 때 기존에는 그냥 해당 dao만 주입받든 생성하든 써주면 되는데 팩토리를 사용하면 팩토리 클래스들, 그러니까 지금 같은 경우는 오라클이랑 mysql에 다 추가를 해줘야합니다.
    더군다나 지금처럼 appConfig를 직접 관리해서 의존성 주입을 받는다고 할 때는 총 3개의 클래스에 관련 내용을 추가해야합니다.
```
![image](https://github.com/chanHyeoks-kingdom/f-lab-history/assets/68278903/d435f77c-d4a8-4412-88d2-e9e75f9a70b6)

<br>

<details>
<summary> 꼬리질문 1. </summary>

###### 꼬리질문 1. 실제 사용 사례가 어떤게 있나요?

```
스프링의 BeanFactory라고 ApplicationContext의 모체가 되는 인터페이스가 있는데, 이런 객체 생성 관리를 탐당하는 컨테이너 등에서 주로 이런 패턴을 자주 사용합니다. 예컨대 getBean 같은  것들을 통해서 빈 객체들을 받아올 수 있습니다.
```

</details>



<details>

<summary> 꼬리질문 2. </summary>

###### 꼬리질문 2. 보니까 예시는 추상 팩토리 패턴인데, 일반 팩토리 패턴과는 무슨 차이가 있나요?

```
팩토리 패턴은 그냥 하나의 객체를 생성하는 방법에 초점을 맞춰 추상화 계층을 추가해주는거고 추상 팩토리 패턴은 관련있는 객체 생성 그룹을 제공하기 위한 인터페이스를 추가해주는 개념입니다.
```

</details>




<details>

<summary> 꼬리질문 3. </summary>

###### 꼬리질문 3. 다른 객체 생성 패턴들이랑 같이 사용할 수도 있나요?
```
네! 당장 SPRING의 applcation context만 봐도 객체 풀링등에 사용되는 싱글톤이랑 방금 말씀드린 factory 패턴을 같이 사용하고 있습니다!
```

</details>


<details>

<summary> 꼬리질문 4. </summary>
    
###### 꼬리질문 4. 이 예시를 구현하면서 자연스럽게 OCP를 사용하셨는데 느끼신 단점은 없으셨나요?
```
OCP를 준수한다는 건 결국 그 안에서 사용되는 모든 객체에 대해 추상화를 진행해야 한다는건데, 이게 생각보다 굉장히 불편했습니다. 당장 AppConfig에 등록하는 부분만 하더라도 추상 팩토리 디자인 패턴이랑
같이 쓰려고 하니까 사실 저 예시에서도 test thread에서 사용하는 객체가 많을수록 효과가 더 극명하게 보여서, 6개 정도로 하려고 했는데 그 과정이 너무 복잡해서 포기했습니다.
```


</details>


<details>


<summary>꼬리질문 5. </summary>

###### 꼬리질문 5. 생성 관련 패턴 중에 다른것도 있는 걸로 알고있는데 무슨 차이가 있나요?
```
간단하게 설명드리면 팩토리 패턴은 특정 작업 수행에 필요한 객체 세트 생성을 서브 클래스에 맡겨 유연성을 높이는 구조입니다. 싱글톤은 하나의 객체만 생성해두고 그 객체 하나만 내려주는 생성 방식이고, 빌더 패턴은 객체 생성을 유연하게 하는 걸 돕는 사
패턴입니다. 프로토타입은 복제를 통해서 생성을 다루는 패턴입니다. 사실 비교라는 걸 하려면 유사한 부분이 있어야하는데 전혀 다른 목적으로 쓰이는 패턴들이어서 객체 생성 방법 외에는 차이라고 할 것도 명확히 표현하기 어렵습니다.
```

</details>


<br>

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#### (2) [Singleton Pattern]
> ##### 객체를 미리 생성해두고, 그 하나의 객체만 내려주는 패턴입니다. 관련 코드는 [여기](https://github.com/choichanhyeok/just-java-note/tree/master/src/main/java/org/example/designPattern/singleton/whyNeedSingleton)에 작성했습니다.
```
데이터베이스 커넥션 풀 처럼 객체들을 요청에 따라 제공하는 경우에 모든 요청마다 객체를 생성한다면 객체 생성하고 해제하는데 들어가는 시간이 많이 들 것입니다. 그래서 이를 위해 객체들을 미리 생성해두고 요청에 따라 할당하게 되면 요청자가 좀 더 기다릴 순 있겠지만
메모리 과부하로 인한 OOME를 방지할 수 있습니다.
```

![image](https://github.com/chanHyeoks-kingdom/f-lab-history/assets/68278903/a82b384f-9723-4c06-8387-ecd3d4ebac43)

![image](https://github.com/chanHyeoks-kingdom/f-lab-history/assets/68278903/6dee176d-92f7-42c8-a686-1e331cb5781e)


<br>

<details>
    <summary> 꼬리질문 1. </summary>

##### 꼬리질문 1. 싱글톤 패턴의 장단점은 무엇인가요?
```
[장점]
a. 자원을 중복해서 생성할 때, 그러니까 위 첨부한 코드처럼 객체 같은 것들을 생성, 해제 하는 비용을 아낄 수 있다는 점입니다. 
b. 특정 자원, 그러니까 객체에 대한 접근을 하나의 클래스에서 처리할 수 있어서 제공할 객체를 교체 할 때 등의 상황에서 인터페이스와 함께 적용하면 유지보수성을 높일 수 있습니다.
```

```
[단점]
a. 일단 하나의 자원을 공유하는 순간부터 동시성 문제는 필연적으로 발생할 수 밖에 없어서 이에 대한 처리가 필요합니다.
b. 전역 상태가 필요해서 코드들의 결합도가 증가하게 됩니다.
```

</details>

<details>
    <summary> 꼬리질문 2. </summary>

##### 꼬리질문 2. 싱글톤 패턴을 사용할 때 고려해야 할 디자인 이슈가 있을까요?
```
싱글톤을 사용 할 때 동시성이나 코드 결합도 문제가 있습니다. 동시성 문제는 double-checked locking 패턴등을 이용해 해결해봤는데, 코드 결합도 문제는 사실 기준을 잘 모르겠습니다.
이게 어쨌든 전역적으로 사용하게 돼서 여기저기서 사용하면 결합도가 높아질 수 있다는 개념인데 지금 생각으론 그냥 인터페이스로 추상화 해서 인터페이스를 통해 접근토록 하는 방법이 있을 거 같습니다.
```

    
</details>

<details>
    <summary> 꼬리질문 3. </summary>

##### 꼬리질문 3. 멀티스레드 환경에서 싱글톤은 어떻게 안전하게 사용할 수 있나요?
```
기존에 배운 synchronized 블록이나 volatile 키워드등을 이용해서 인스턴스 생성 시 발생하는 race-condition을 방지할 수 있습니다.
그 외에 dobule-checked locking등의 방법을 활용할 수도 있을 거 같습니다.
```

    
</details>

<details>
    <summary> 꼬리질문 4. </summary>

##### 꼬리질문 4. 싱글톤 패턴과 데이터베이스 커넥션 풀의 관계는 어떻게 설명할 수 있나요?
```
싱글톤 패턴은 데이터커넥션 풀 관리와 함께 사용될 경우 큰 이점을 가져갈 수 있습니다. 싱글톤은 동시성 이슈의 해결 방안으로 synchronized 같은 방법을
사용할 경우가 많은데 그로 인해 무조건 하나만 사용했을 땐 성능상 불이익을 가져갈 수 있습니다. 이 때 데이터베이스 커넥션 풀과 같은 풀의 요소로서 사용
될 경우 객체 관리 비용을 줄이면서 성능상 이점도 어느정도 보완갈 수 있습니다.
```

    
</details>

<details>
    <summary> 꼬리질문 5. </summary>

##### 꼬리질문 5. 싱글톤 인스턴스의 생성을 지연시키는 이유는 무엇인가요?
```
리소스 절약을 위해서입니다. 애플리케이션이 시작할 때 부터 생성해두면 '초기 로딩 시간'을 늦출 수 있는데 이런 부분을 해결할 수 있습니다.
```

    
</details>

<details>
    <summary> 꼬리질문 6. </summary>

##### 꼬리질문 6. 싱글톤 패턴을 사용하지 않고 데이터베이스 커넥션을 관리하는 다른 방법은 무엇인가요?
```
HikariCp 같은 연결 풀 라이브러리를 사용하거나 DI를 이용하는 방법도 있는데 사실 이게 싱글톤 패턴이랑 완전히 분리된 개념들은 아니라고 생각합니다.
```

    
</details>


<details>
    <summary> 꼬리질문 7. </summary>

##### 꼬리질문 7. 스프링에서도 Application Context를 이용해 DI를 제공하지 않나요? 어떤식으로 싱글톤의 단점을 보완하나요?
```
일단 인터페이스 기반의 추상화와 DI를 통해 결합도를 감소시키고 내부적으로 동기화 문제를 해결해줍니다.
```

    
</details>


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<br>

#### (3) [Adapter Pattern]
> ##### 서로 호환되지 않는 클래스들을 호환할 수 있도록 중간에서 관리토록 하는게 어뎁터 패턴입니다. 관련 코드는 [여기]()를 참조해주세요.
```
어뎁터 패턴은 기존 시스템에 새로운 클래스나 모듈을 통합하고자 할 때 쓰이곤 하는데 스프링 MVC에서도 어뎁터 패턴의 적용을 확일할 수 있습니다.
```




<details>
    <summary> 꼬리질문 1. </summary>
    
##### 꼬리질문 1. 
```

```
    
</details>

<details>
    <summary> 꼬리질문 2. </summary>
    
##### 꼬리질문 2. 
```

```
    
</details>



--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<br>

### 2. 스프링의 IoC(Inversion of Control)과 DI(Dependency Injection)에 대해 설명하시오
> IoC라는 건 `객체의 생성부터 생명주기 관리 관련된 제어 권한을 프레임워크 쪽에 넘기는 걸 의미`하는데요, `이를 위해 사용할 수 있는 도구 중에 하나`가 DI 입니다. 스프링에서는 IoC의 `BeanFactory`나 `ApplicationContext`라는 인터페이스로 정의했고 이를 구현한 다양한 구현체를통해 DI를 손쉽게 제공합니다.
```
DI는 앞전의 코드에서 봤듯이 AppConfig 같은 컨테이너를 이용해서 각자 클래스 내부에서 직접 객체를 생성치 않고 객체의 생명주기를 관리하는 별도 클래스를 사용하는 걸 의미하는데요, 스프링에서 이런 걸 해주는 개념이 BeanFactory와 ApplicationContext입니다.
사실 ApplicationContext도 BeanFactory를 상속받는 개념인데 메시지 국제화, 이벤트 발행등의 더 많은 기능을 제공합니다. 그래서 이런 개념들을 실제로 구현한 AnnotationConfgApplicationContext 같은 구현체를 이용해 빈이라는 이름으로 객체들을 관리합니다.
```
<br>


<details>
    <summary> 꼬리질문 1. </summary>
    
##### 꼬리질문 1. 빈을 등록하는 방법엔 어떤 것들이 있나요?
```
빈을 등록하기 위해서 XML을 사용하는 방법도 있고 특정 클래스에 @Configuration을 붙이고 그 하위에 객체를 주입해주는 메서드들을 작성한 뒤 @Bean 애노테이션으로 등록해주는 방법이 있습니다.
```
    
</details>

<details>
    <summary> 꼬리질문 2. </summary>
    
##### 꼬리질문 2. 구체적으로 저 애플리케이션 컨텍스트는 어떤 프레임워크에 종속된건가요?
```
스프링 프레임워크요. 정확히는 스프링 컨텍스트 라이브러리요.
```
    
</details>


<details>
    <summary> 꼬리질문 3. </summary>
    
##### 꼬리질문 3. "DI 없이도 애플리케이션을 개발할 수 있나요? 그렇다면 왜 DI를 사용하는 건가요?"
```
DI 없이도 애플리케이션을 개발할 순 있습니다. 근데 소프트웨어가 변경 용이한 상태로 계속 유지되려면 모듈을 쉽게 교체가능한 상태로 유지해야하고 이를 충족시키기 위한 방법 중 하나가 DI 입니다. 앞서 말한 팩토리 같은 것들을 이용해도
비슷한 효과를 얻어낼 수 있긴 할 거 같습니다.
```
    
</details>



<details>
    <summary> 꼬리질문 4. </summary>
    
##### 꼬리질문 4. 싱글톤 빈과 프로토타입 빈의 차이는 무엇인가요?
```
싱글톤 빈은 컨테이너 내에 단 하나만 생성되어 모든 요청에서 공유된느 반면, 프로토 타입 빈은 요청할 때 마다 새로운 객체가 생성됩니다. 싱글톤 빈은 메모리 사용에서 효율적이지만 상태를 공유해야하고 프로토타입 빈은 메모리를 많이 소모
하지만 독립적으로 다뤄질 수 있습니다.
```
    
</details>

<details>
    <summary> 꼬리질문 5. </summary>
    
##### 꼬리질문 5. 스프링에서 XML 기반 설정과 자바 기반 설정의 차이점은 무엇인가요?
```
자바 기반에 Configuration 사용하는 건 아무래도 프로그래밍 레벨에서 다루는거다 보니까 동적으로 처리할 때 이점이 있을 거 같긴 한데, 그냥 다루는 형식 정도의 차이가 있구나 정도만 이해가 가고
타입 안전성과 리팩토링 용이성이라는 장점이 있다곤 하던데 그렇게 와닿지는 않는 상태입니다.
```
    
</details>





--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


### 3. 스프링 빈 주입 방법에 대해 설명하시오
> Bean을 주입하는 방법은 ApplicationContext 객체를 통해 수동으로 getBean()을 하거나 @Autowired 애노테이션을 이용해 자동으로 빈을 주입할 수 있습니다.
```
이 과정에서 여러 주입 방법이 있는데 대체로 생성자 주입이 선호됩니다. 필드 주입, 세터 주입등은 .. 같은 문제들이 있어 일반적으로 권고되지 않는 방법이라고 알고 있습니다.
```

<details>
    <summary> 꼬리질문 1. </summary>
    
##### 꼬리질문 1. 세터나 필드 주입은 왜 기피되나요?
```
세터나 필드 주입은 객체 생성 이후에 외부에서 값을 마음대로 바꿀 수 있게 되어 버려서 문제가 있을 수 있구요, 생성자 주입을 이용하면 이런 문제를 불변성을 이용해 해결할 수 있고 의존관계를 생성자에서 한 번에 확인할 수도 있습니다.
이런 이유로 스프링 팀에서 권고하는 사항이기도 하고 순환 의존성이 발생할 수 있는데 생성자에 대해  ** 아직 순환 의존성 관련 공부 진행 중 **
```
    
</details>

<details>
    <summary> 꼬리질문 2. </summary>
    
##### 꼬리질문 2. 컴포넌트라는게 있던데 그건 뭐예요?
```
이제 컴포넌트 애노테이션을 붙여두면 스프링 부트가 실행될 때 컴포넌트 스캔이란 작업을 진행해서 컴포넌트들을 스프링 컨테이너에 다 등록해둡니다. 스프링 프레임워크에선 별도로 호출해줘야 하구요. 어쨌든
그래서 개발자는 별도의 @Configuration 클래스나 XML을 직접 관리할 필요 없이 @Compoment만 붙여두면 언제든지 @Autowired나 @RequiredArgsConstruct 같은 것들을 이용해 변수 정의만으로
의존성을 주입받을 수 있습니다.
```
    
</details>


<details>
    <summary> 꼬리질문 3. </summary>
    
##### 꼬리질문 3. 스프링 부트가 아닌데 컨트롤러는 컴포넌트가 있고, 그럼 그 컴포넌트는 여태까지 누가 스캔한거지?
```
어디선가 컴포넌트 스캔을 따로 해줬던 걸거야 .. @Configuration 하위나 별도 xml에서 말이야.
```
    
</details>


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



### 4. Spring AOP(Aspect-Oriented Programming)에 대해 설명하시오
> Spring AOP는 많은 코드에 공통적으로 들어가는 같은 형태의 코드를 분리하기 위해 고안된 AOP라는 프로그래밍 패러다임을 AspectJ와 SpringFramework의 SpringContext등을 통해 스프링에서 구현한 AOP가 스프링 AOP입니다. 내부적으로 프록시를 이용하고 이를 구현하기 위해 자바 표준 java.lang.relfect에서 제공하는 java 동적 프록시나 스프링 프레임워크의 내부에서 사용하는 CGLIB을 사용합니다.
```

```
<br>


<details>
    <summary> 꼬리질문 1. </summary>
    
##### 꼬리질문 1. AOP의 주요 용어(Aspect, Join Point, Advice, Pointcut, Weaving)에 대해 설명해주세요.
```
Aspect는 횡단 관심사를 모듈화한 거, Join Point 는 Aspect 어디 적용할건지, Advice는 코드가 특정 Join point의 전에 실행될건지 후에 실행될건지 등을 지정, pointcut은 어떤 메소드들을 대상으로 할건지를 정의합니다. weaving은 aspect를 대상 객체에 적용해서 프록시 객체를 생성하는 과정을 말하고
컴파일, 로드 타임, 런타임 등의 시점에 수행될 수 있습니다.
```
```

@Aspect
public class LoggingAspect {

    // Pointcut 정의: 모든 service 패키지 내의 메소드들을 대상으로 함
    @Pointcut("execution(* com.example.service.*.*(..))")
    private void forServiceLayer() {}

    // Advice 정의: 메소드 실행 전
    @Before("forServiceLayer()")
    public void beforeAdvice() {
        System.out.println("====> Logging BEFORE method execution");
    }

    // Advice 정의: 메소드 실행 후
    @After("forServiceLayer()")
    public void afterAdvice() {
        System.out.println("====> Logging AFTER method execution");
    }

    // Advice 정의: 메소드 실행 주변 (전후)
    @Around("forServiceLayer()")
    public Object aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println("====> Logging AROUND method execution START");
        Object result = proceedingJoinPoint.proceed(); // 실제 메소드 실행
        System.out.println("====> Logging AROUND method execution END");
        return result;
    }
}
```

    
</details>

<details>
    <summary> 꼬리질문 2. </summary>
    
##### 꼬리질문 2. 스프링 AOP와 AspectJ AOP의 차이점은 무엇인가요?
```
스프링 AOP는 주로 런타임에서 빈을 내려줄 때 바꿔치기 하는 방식을 이용해 위빙을 사용합니다. 반면에 AspectJ는 위빙 시점이 컴파일, 로드 시점 다 지원해서 더 정밀하게 적용가능한데 일단 코드 몇 줄 쳐봤을 땐
굉장히 복잡하다는 단점이 있는 거 같습니다.
```
    
</details>


<details>
    <summary> 꼬리질문 3. </summary>
    
##### 꼬리질문 3. 스프링 AOP에서 Aspect를 구현하는 방법은 어떤 것들이 있나요?
```
일단 AspectJ의 Aspect 애노테이션을 사용하는 방법이 있습니다.
```
    
</details>



<details>
    <summary> 꼬리질문 4. </summary>
    
##### 꼬리질문 4. 트랜잭션 관리에서 AOP를 어떻게 활용할 수 있나요?
```
@Transactional 애노테이션이요 .. 트랜잭션 관리할 때 쓰는건데 그냥 저거 붙여주면 해당 트랜잭션 영역이 트랜잭션으로 묶이는 프록시 객체가 생성됩니다. 요 놈도 스프링이 빈으로 관리해줘서 바꿔치기가 가능한겁니다.
```
    
</details>


<details>
    <summary> 꼬리질문 5. </summary>
    
##### 꼬리질문 5. AOP를 사용할 때 주의해야 할 점은 무엇인가요?
```
결국 동적으로 프록시 객체를 생성하는 것이기 떄문에 메모리 측면에서 문제가 생기지 않을지 고려해봐야 합니다.
```
    
</details>


<details>
    <summary> 꼬리질문 6. </summary>
    
##### 꼬리질문 6. 실제 프로젝트에서 AOP를 적용하는 과정을 말씀해주세요
```
가장 먼저 저희는 Aspect라는 걸 등록해야 합니다. 이건 AspectJ에서 제공하는 애노테이션을 통해 적용할 수 있는데요 그 안에 해당 Aspect를 적용할 범위인 JoinPoint라는 걸 Pointcut등을 이용해 지정할 수 있습니다.
그 안에는 Advice 애노테이션을 통해 실제 적용할 로직을 작성하게 되면 프록시에 주입할 Aspect 작성을 마무리한다고 가정하고, 이제 해당 Aspect는 스프링에 의해서 프록시 객체로 변환되는 설정 파일 역할을 하게 되는데
저희가 컴포넌트를 써서 별도 컨피규레이션을 이용해 컴포넌트 스캔을 하던 컨피규레이션 클래스에 빈으로 직접 등록을 하던 어찌됐건 빈으로서 관리하게 되야 스프링에서 저 Aspect 기반으로 해당 빈에 맞는 프록시 객체를
바꿔치기 할 수 있어서요! 빈으로 등록해줘야 하고, @EnnableAspectJAutoProxy 애노테이션 이용해서 프록시 생성 객체 활성화를 해주면 빈 주입시에 실제 객체 대신 프록시 객체를 주입해주게 됩니다.
그럼 실제 사용할때는 Aspect에서 정의한 Advice 부분들이 적용된 클래스를 사용할 수 있게 됩니다!

```
    
</details>


<details>
    <summary> 꼬리질문 7. </summary>
    
##### 꼬리질문 7. 실제 프로젝트에서 AOP를 적용한 예제를 들어줄 수 있나요?
```
특정 업무단의 서비스에 대한 로깅등에 적용할 수 있을 거 같습니다.
```
    
</details>


<details>
    <summary> 꼬리질문 8. </summary>
    
##### 꼬리질문 8. 자바 동적 프록시랑 CGLIB 직접 사용해본 적 있나요?
```
네. 지금 써보려구여,
```
    
</details>


<details>
    <summary> 꼬리질문 9. </summary>
    
##### 꼬리질문 9. AOP에서 프록시 객체를 생성하는 시점은 언제예요?
```
AspectJ 같은 도구는 컴파일시점에,  클래스 로드나 런타임 시점도 있는 걸로 알고 있습니다. 런타임 시점은 Bean 생성시에 스프링에 의해 생성되는 것들이 있는데. 이건 솔직히 잘 이해 못하고 있습니다.
요구사항에 따라 다르게 적용하면 될 거 같은데, 더 알아보고 싶습니다.
```
    
</details>

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


### 5. Git Branch 전략에 대해 설명하시오 (eg. git flow, github flow, etc)
> Git branch는 핫픽스, 디벨롭, 릴리즈, 피처등의 역할이 분명한 브랜치들을 사용하는 브랜치 전략입니다. 반면 GitHub flow는 메인과 피처 브랜치만 두고 개발하는 브랜치 전략으로 소규모 개발과 CI/CD가 구축된 상황에 적합합니다.
```
결론적으로, Git Flow는 복잡한 프로젝트 관리와 긴급 수정에 강점을 가지는 반면, GitHub Flow는 단순성, 명확성, 그리고 지속적인 배포에 적합한 구조를 제공합니다. 프로젝트의 규모, 팀의 작업 방식, 배포 주기 등을 고려하여 가장 적합한 워크플로우를 선택하는 것이 중요합니다.
```
<br>


<details>
    <summary> 꼬리질문 1. </summary>
    
##### 꼬리질문 1. Git Flow에서 hotfix 브랜치는 어떤 상황에서 사용하나요? 
```

```
    
</details>

<details>
    <summary> 꼬리질문 2. </summary>
    
##### 꼬리질문 2. GitHub Flow를 사용할 때, 기능 개발이나 버그 수정 작업을 어떻게 관리하나요?
```

```
    
</details>


<details>
    <summary> 꼬리질문 3. </summary>
    
##### 꼬리질문 3. Git Flow와 GitHub Flow 외에 다른 Git 브랜치 전략이 있나요?
```

```
    
</details>



<details>
    <summary> 꼬리질문 4. </summary>
    
##### 꼬리질문 4. GitHub Flow에서는 코드 리뷰 과정을 어떻게 구성하나요?
```

```
    
</details>

<details>
    <summary> 꼬리질문 5. </summary>
    
##### 꼬리질문 5. 복잡한 프로젝트에서 Git Flow의 복잡성을 관리하는 방법은 무엇인가요?
```

```
    
</details>



<details>
    <summary> 꼬리질문 6. </summary>
    
##### 꼬리질문 6. 실제 프로젝트에서 Git Flow나 GitHub Flow를 적용했을 때의 경험담을 들려줄 수 있나요?
```

```
    
</details>




