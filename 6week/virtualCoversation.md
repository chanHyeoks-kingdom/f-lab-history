
```
[이 주의 과제]
1. JDBC에 대해 설명하시오 (키워드: 드라이버, 트랜잭션, Statement vs PreparedStatement, ResultSet)
2. DB Connection Pool의 동작원리에 대해 설명하시오
3. 데이터베이스 clustered index vs non-clustered index에 대해 설명하시오
4. 객체 지향 설계 5원칙 - SOLID (vs 다른 개발 원칙)
```



<br>

## 1. JDBC에 대해 설명해주세요

> ###### a. 자바에서 `DB를 다루기 위해 필요한 것들을 정의해둔 인터페이스`입니다. `각 DBMS 별로 이에 대한 내용을 실제 구현`해뒀는데 `이런 구현체들을 JDBC 드라이버`라고 합니다.
> ###### b. JDBC 드라이버는 DB 연결을 위한 커넥션 객체를 할당하거나 쿼리를 다루기 위한 Statement, PreparedStatement를 `mysql.cj.jdbc.ClientPreparedStatement` 같은 구현체를 통해 제공하고있고 SELECT 문의 결과를 다루기 위한 ResultSet의 구현을 제공하고 있습니다.



>#### 꼬리질문 1. Statement, PreparedStatement를 이용해 쿼리를 다룰 수 있다고 하셨는데 둘의 차이가 뭔가요?
>> ##### a. Statement 객체는 쿼리 실행을 위해 execute() 메서드를 실행할 때 `스트링으로 된 쿼리 자체를 넘겨`줍니다. 이 과정에서 사용자 입력에 의해 `동적으로 쿼리를 처리하기 위해 String에 대한 '+' 연산등을 사용할 경우 SQL 인젝션` 같은 보안상의 문제가 있습니다. 다만 `단순 정적 쿼리 실행시을 위해`서 String으로 된 쿼리만 넘겨주면 되다보니까 `좀 더 직관적`입니다.  
>> ##### b. 반면 PreparedStatement는 `동적으로 처리할 부분에 '?' 플레이스 홀더`를 지정하고 `setString(), setInt()등의 메서드를 이용`해 사용자 입력에 맞는 쿼리를 처리합니다. 이 과정에서 `쿼리 인젝션을 방지`할 수 있다는 장점이 있고 `쿼리 자체를 미리 컴파일해두고 값만 교체`하기 때문에 이 과정에서 좀 더 빠르게 동작합니다.



>#### 꼬리질문 2. 그럼 ResultSet은 뭐예요?
>> ##### a. SELECT 관련된 쿼리를 던질 때 executeQuery() 메서드를 사용하는데 이 때 `조회된 결과값을 다루기 위해 필요한 클래스`입니다.



> #### 꼬리질문 3. 혹시 트랜잭션 같은 개념도 공부해 본 적 있나요?
>> ##### a. 트랜잭션이란 건 내가 하려는 작업의 최소 단위를 의미하는데요, 예를 들어 고객이 앱을 통해 옷을 구매할 때 옷의 값을 지불 잔액을 DB에 저장하고 판매 성공 여부를 DB에 적재해야 한다고 할 때 판매 성공 여부를 등록하는 과정에서 문제가 생기는 경우가 있을 수 있습니다. 이럴 때 '돈만 내고 구매는 못하는 상황'이 생기는데 이런 걸 방지하기 위해 '옷 대금 지불과 판매 완료 여부 등록'은 항상 하나의 작업으로 같이 실패하고 같이 성공해야합니다. 이걸 원자성이라고 부르는데 이런 이유로 최소 작업 단위를 만들어두고 관리하는데 '트랜잭션'이라는 개념이 필요합니다.
>> ##### b. 어쨌든 JDBC를 사용할 때 `'쿼리를 실행하는' 메서드를 수행할 때 기본 설정은 무조건 바로 커밋을 치도록` 되어있습니다. 이 경우 저런 `트랜잭션을 컨트롤할 수 없기 때문에` Connection 객체에서 setAutoCommit() 메서드를 통해 `오토 커밋을 꺼주고` 직접 작업 종료 후 직접 커밋토록, 익셉션 발생시 롤백 하도록 지정하는 방식으로 트랜잭션을 구현할 수 있습니다.


> #### 꼬리질문 4. 그럼 애플리케이션 레벨 말고 DB 레벨에서 격리레벨 같은 거 공부해보신적은요 ?
>> ##### a. 격리성 레벨에 따라 발생할 수 있는 문제들에 대한 대략적인 이해와 ACID 정도만 이해하고 있습니다.


> #### 꼬리질문 5. JDBC 관련해서 best practice는 한 번 따라 쳐 보셨어요?
>> ##### b. 지금 쳐보려구용 ..


<br><br>

## 2. DB Connection Pool의 동작원리에 대해 설명해주세요
> ###### a. 어쨌든 DB에 연결한다는 건 TCP 통신이고, 이 과정에서 3-way-handshake, 4-way-handshacke 처럼 신뢰성 있는 연결을 위해 싱크를 맞추며 연결하는 과정에서 시간이 소요됩니다. 그래서 결론은 '연결'을 하는 작업은 비용이 꽤 많이 드는데요, `애초에 연결 객체 만들어두고 계속 쓰면 이 비용을 줄일 수 있지 않을까?`라는 생각으로 커넥션 객체들을 미리 생성해두고 할당하는 방식을 사용하는데 이런 객체들을 관리하는게 DB Connection Pool입니다. 대표적으로 이를 지원하는게 HikariCP라는게 있구요, 이건 JDBC에 보면 DataSource라고 데이터 커넥션을 관리하는 클래스가 있는데 이걸 구현한 구현체입니다. 



>#### 꼬리질문 2. 그럼 무조건 커넥션 풀 많으면 좋겠네요?
>> 사실 커넥션 풀에서 커넥션을 가져다 쓰는것도 결국 CPU를 할당 받아야 하기 때문에 쓰레드 개수도 고려를 해야합니다. 또 사실 이 스레드 자체도 결국 컨텍스트 스위칭을 통해 하나씩 CPU를 할당받는데 이 과정에 드는 비용도 있어서 한계가 있습니다. 그리고 애초에 DB는 Disk IO인


>#### 꼬리질문 3. 아니 그러면 커넥션 풀 뭐 어쩌라는건데요
>> mysql 제공 문서 보면 600명 기준 15개가 가장 효율적이라던지, HikariCP 제공 문서 보면 무슨 공식 같은게 있긴 했는데 솔직히 잘 모르겠습니다.

>#### 꼬리질문 4. 쓰는 주체가 어딘가요?
>> 톰캣같은 WAS는 자체 커넥션 풀이 있고, 스프링같은 내부적으로 HikariCP를 탑재하고 있는걸로 알고있고 ~~ 파일을 통해 커넥션 풀 설정을 관리할 수 있습니다.




<br><br>

## 3. 데이터베이스 clustered index vs non-clustered index에 대해 설명하시오
```
인덱싱을 했을 때 해당 테이블을 직접 다루냐 별도 인덱스 테이블을 만드냐의 차이가 있습니다.
```

> ###### a. 클러스터형 인덱스는 테이블 요소의 변경이 있을 떄 마다 인덱스로 지정된 필드의 값에 따라 테이블의 데이터를 물리적으로 정렬하는 인덱싱 방법입니다. 때문에 테이블 당 하나만 만들 수 있고 균형잡힌 B트리를 순회할 때 더 효율적으로 값을 조회할 수 있습니다. 다만 데이터가 변경될 때 마다 테이블을 정렬해야하는 비용을 지불해야 합니다. mysql의 경우는 기본 설정이 pk에 대해서 자동으로 걸어주는 걸로 이해하고 있고 오라클은 IoT라는 개념으로 활용하는거로 이해했는데, 이 부분은 자세히 공부진 못하는 상태입니다. 
> ###### b. 논 클러보조 인덱스라고 별도의 인덱스 테이블들을 만들고 이 값을 정렬한 뒤 균형 잡힌 B 트리의 형태로 활용하는 인덱싱 방법입니다. 이를 통해 해서 여러개를 만들 수 있습니다.


>#### 꼬리질문 1. 인덱스는 왜 효율적인가요?
> ###### a. 내부적으로 .. 아 사실 이 트리라는 것도 내부적으론 배열이고 트리는 추상화된 개념이긴 한데, 어쨌든 균형잡힌 B-Tree라는 컨셉을 사용하고 있어서 대수 확장성이라는 걸 갖거든요! 그래서 O(logN)의 시간복잡도를 갖습니다.
> ###### b. 그래서 그냥 정렬과 논 클러스터 인덱스 기준라면 메모리 비용도 있겠지만 어쨌든 이런 비용을 지불하고 검색 속도를 얻을 수 있습니다.

>#### 꼬리질문 2. 각각 어떨 때 쓰면 좋나요?

+ 데이터 변경이 적고 조회가 많은 경우에 쓰면 좋습니다.

>#### 꼬리질문 3. 대수 확장성이 뭐예요?
>> 이게 어려울 말로 하면 데이터의 양이 증가하면서 필요한 작업량이 증가할 텐데 이 작업량이 '로그 함수의 증가율'을 따른다는 말인데, 그냥 리프 노드의 개수가 이전 리프 노드의 개수에 n 제곱으로 증가한다는 의미로 이해하고 있습니다. 그래서 트리를 탐색할 때 트리의 깊이가 적다보니까 탐색해야 하는 횟수가 줄어듦을 의미하고 이 덕분에 인덱스에 대한 탐색은 O(logN)의 시간복잡도를 가질 수 있게됩니다. 물론 논 클러스터 인덱스의 경우에는 인덱스를 찾는데는 또 O(N)의 시간 복잡도가 들겠지만요.

>#### 꼬리질문 4. 균형잡혔다는 말의 의미가 뭐예요?
>> B-트리나 B+트리 같은 트리들이 데이터를 삽입하거나 삭제할 때, 트리의 높이를 가능한 한 낮게 유지하여 모든 리프 노드가 대략 같은 레벨에 있도록 만드는 것을 의미합니다. 그래서 이 조건만 충족하면 뭐가 됐든 균형잡힌 B트리로 표현할 수 있

>#### 꼬리질문 5. 인덱스를 안쓰는 테이블은 어떤 시간복잡도를 갖나요?
>> Heap을 써서 탐색하다 보니까 풀 스캔을 해서 O(N)입니다.

>#### 꼬리질문 6. 실제 쓰려면 어떻게 쓰죠?
>> DBMS 마다 다른데, 사실 오라클 보면 IoT 같은 것들도 있고 뭔가 복잡해보여서 실습을 못해봤고 mysql 기준으로 하면 클러스터형 인덱스는 PK로 정의하면 자동으로 클러스터형 인덱스로적용 되는거로 이해했고 `CREATE INDEX 인덱스 이름 ON 테이블 명(필드명);`으로 생성하는 것만 해봤습니다!

>#### 꼬리질문 7. 어떤 기준으로 사용하나요?
>> 같음, 정렬, 다중, 유니크 .. 근데 사실 뭔가 테이블이나 데이터의 형태 등 ..복잡하게 생각해야 할 문제 같아서 잘 모르겠음

<br><br>

## 4. 객체 지향 설계 5원칙 - SOLID (vs 다른 개발 원칙) [[참고 1], ](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID)
> ###### a. 
> ###### b. 



