
```
[이 주의 과제]
1. JDBC에 대해 설명하시오 (키워드: 드라이버, 트랜잭션, Statement vs PreparedStatement, ResultSet)
2. DB Connection Pool의 동작원리에 대해 설명하시오
3. 데이터베이스 clustered index vs non-clustered index에 대해 설명하시오
4. 객체 지향 설계 5원칙 - SOLID (vs 다른 개발 원칙)
```



<br>

## 1. JDBC에 대해 설명해주세요

> ###### a. 자바에서 `DB를 다루기 위해 필요한 것들을 정의해둔 인터페이스`입니다. `각 DBMS 별로 이에 대한 내용을 실제 구현`해뒀는데 `이런 구현체들을 JDBC 드라이버`라고 합니다.
> ###### b. JDBC 드라이버는 DB 연결을 위한 커넥션 객체를 할당하거나 쿼리를 다루기 위한 Statement, PreparedStatement를 `mysql.cj.jdbc.ClientPreparedStatement` 같은 구현체를 통해 제공하고있고 SELECT 문의 결과를 다루기 위한 ResultSet의 구현을 제공하고 있습니다.



>#### 꼬리질문 1. Statement, PreparedStatement를 이용해 쿼리를 다룰 수 있다고 하셨는데 둘의 차이가 뭔가요?
>> ##### a. Statement 객체는 쿼리 실행을 위해 execute() 메서드를 실행할 때 `스트링으로 된 쿼리 자체를 넘겨`줍니다. 이 과정에서 사용자 입력에 의해 `동적으로 쿼리를 처리하기 위해 String에 대한 '+' 연산등을 사용할 경우 SQL 인젝션` 같은 보안상의 문제가 있습니다. 다만 `단순 정적 쿼리 실행시을 위해`서 String으로 된 쿼리만 넘겨주면 되다보니까 `좀 더 직관적`입니다.  
>> ##### b. 반면 PreparedStatement는 `동적으로 처리할 부분에 '?' 플레이스 홀더`를 지정하고 `setString(), setInt()등의 메서드를 이용`해 사용자 입력에 맞는 쿼리를 처리합니다. 이 과정에서 `쿼리 인젝션을 방지`할 수 있다는 장점이 있고 `쿼리 자체를 미리 컴파일해두고 값만 교체`하기 때문에 이 과정에서 좀 더 빠르게 동작합니다.



>#### 꼬리질문 2. 그럼 ResultSet은 뭐예요?
>> ##### a. SELECT 관련된 쿼리를 던질 때 executeQuery() 메서드를 사용하는데 이 때 `조회된 결과값을 다루기 위해 필요한 클래스`입니다.



> #### 꼬리질문 3. 혹시 트랜잭션 같은 개념도 공부해 본 적 있나요?
>> ##### a. 트랜잭션이란 건 내가 하려는 작업의 최소 단위를 의미하는데요, 예를 들어 고객이 앱을 통해 옷을 구매할 때 옷의 값을 지불 잔액을 DB에 저장하고 판매 성공 여부를 DB에 적재해야 한다고 할 때 판매 성공 여부를 등록하는 과정에서 문제가 생기는 경우가 있을 수 있습니다. 이럴 때 '돈만 내고 구매는 못하는 상황'이 생기는데 이런 걸 방지하기 위해 '옷 대금 지불과 판매 완료 여부 등록'은 항상 하나의 작업으로 같이 실패하고 같이 성공해야합니다. 이걸 원자성이라고 부르는데 이런 이유로 최소 작업 단위를 만들어두고 관리하는데 '트랜잭션'이라는 개념이 필요합니다.
>> ##### b. 어쨌든 JDBC를 사용할 때 `'쿼리를 실행하는' 메서드를 수행할 때 기본 설정은 무조건 바로 커밋을 치도록` 되어있습니다. 이 경우 저런 `트랜잭션을 컨트롤할 수 없기 때문에` Connection 객체에서 setAutoCommit() 메서드를 통해 `오토 커밋을 꺼주고` 직접 작업 종료 후 직접 커밋토록, 익셉션 발생시 롤백 하도록 지정하는 방식으로 트랜잭션을 구현할 수 있습니다.


> #### 꼬리질문 4. 그럼 애플리케이션 레벨 말고 DB 레벨에서 격리레벨 같은 거 공부해보신적은요 ?
>> ##### a. 격리성 레벨에 따라 발생할 수 있는 문제들에 대한 대략적인 이해와 ACID 정도만 이해하고 있습니다.


> #### 꼬리질문 5. JDBC 관련해서 best practice는 한 번 따라 쳐 보셨어요?
>> ##### b. 지금 쳐보려구용 ..


<br><br>

## 2. DB Connection Pool의 동작원리에 대해 설명해주세요
> ###### a. 어쨌든 DB에 연결한다는 건 TCP 통신이고, 이 과정에서 3-way-handshake, 4-way-handshacke 처럼 신뢰성 있는 연결을 위해 싱크를 맞추며 연결하는 과정에서 시간이 소요됩니다. 그래서 결론은 '연결'을 하는 작업은 비용이 꽤 많이 드는데요, `애초에 연결 객체 만들어두고 계속 쓰면 이 비용을 줄일 수 있지 않을까?`라는 생각으로 커넥션 객체들을 미리 생성해두고 할당하는 방식을 사용하는데 이런 객체들을 관리하는게 DB Connection Pool입니다. 대표적으로 이를 지원하는게 HikariCP라는게 있구요, 이건 JDBC에 보면 DataSource라고 데이터 커넥션을 관리하는 클래스가 있는데 이걸 구현한 구현체입니다. 



>#### 꼬리질문 2. 그럼 무조건 커넥션 풀 많으면 좋겠네요?
>> 사실 커넥션 풀에서 커넥션을 가져다 쓰는것도 결국 CPU를 할당 받아야 하기 때문에 쓰레드 개수도 고려를 해야합니다. 또 사실 이 스레드 자체도 결국 컨텍스트 스위칭을 통해 하나씩 CPU를 할당받는데 이 과정에 드는 비용도 있어서 한계가 있습니다. 그리고 애초에 DB는 Disk IO인


>#### 꼬리질문 3. 아니 그러면 커넥션 풀 뭐 어쩌라는건데요
>> mysql 제공 문서 보면 600명 기준 15개가 가장 효율적이라던지, HikariCP 제공 문서 보면 무슨 공식 같은게 있긴 했는데 솔직히 잘 모르겠습니다.

>#### 꼬리질문 4. 쓰는 주체가 어딘가요?
>> 톰캣같은 WAS는 자체 커넥션 풀이 있고, 스프링같은 내부적으로 HikariCP를 탑재하고 있는걸로 알고있고 ~~ 파일을 통해 커넥션 풀 설정을 관리할 수 있습니다.




<br><br>

## 3. 데이터베이스 clustered index vs non-clustered index에 대해 설명하시오

> ###### a. 
> ###### b. 



<br><br>

## 4. 객체 지향 설계 5원칙 - SOLID (vs 다른 개발 원칙)
> ###### a. 
> ###### b. 



