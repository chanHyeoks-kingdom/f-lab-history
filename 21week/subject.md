## 1. 데이터베이스 ACID vs CAP에 대해서 알려주세요
- ACID는 데이터베이스에 데이터를 안전하게 저장하고 관리하기 위한 방법이고 
- CAP는 분산 DB를 위한, 그러니까 여러 컴퓨터에 데이터를 나눠 저장할 때 고려하는 3가지 방법입니다.

> a. ACID
```
- Atomic하게!: 데이터베이스에서 일어하는 작업은 기면 기고 아니면 아니여야 한다는 뜻입니다. 작업이 성공하면 다같이 성공하고, 중간에 문제가 하나라도 있으면 그냥 실패처리하고 롤백 하라는 전략입니다.
- Consistency하게: 데이터베이스는 규칙을 일관적으로 우직하게 지키라는 의미입니다. 예컨대 DB에서 정해둔 규칙이 있으면 그거 잘 지키라는 의미입니다.
- Isolation: 데이터베이스에서 일어나는 각 작업(트랜잭션)은 고립되어야 해서 다른 작업의 결과가 나한테 영향을 주면 안된다는 뜻입니다.
- Durability: 데이터베이스는 내구성이 좋아야 한다는 뜻입니다. 
```

> b. CAP
```
- Consistency: 분할된 상태의 데이터베이스는 항상 같은 값으로 동기화되어 있어야 한다는 의미입니다.
- Available: 데이터베이스는 언제나 사용 가능한 상태를 유지해야 한다는 의미입니다.
- Partition Tolerance: 하나의 컴퓨터가 망가져도 다른 컴퓨터에서 작업을 할 수 있는 상태를 유지하는 DB 분할을 통한 장애 내성을 키우라는 권고입니다.
```

<br>

#### [중요 Keyword]
-  CAP를 모두 준수하는 건 어렵다. 아래 케이스들을 보자.

> a. (P)분할 내성과 (A)가용성을 보장할 때의 (C) 일관성 문제
```
(1) 네트워크 장애가 발생해 특정 DB에 대한 접근이 안될 때도 가용성을 위해선 DB를 사용할 수 있어야 한다.
(2) 기존에 분할 내성을 준수해 여러 DB에 값을 잘 동기화 해둬서 사용은 문제가 없지만
(3) 네트워크 장애 이후 다시 동기화 과정을 거치지 않거나, 장애가 유지되고 있는 상태에선 특정 DB에 대한 불일치 문제가 발생해 일관성을 준수할 수 없게된다.
```

> b. (C)일관성과 (P)분할 내성을 지키고자 할 때 (A)가용성의 문제
```
(1) 네트워크 장애가 발생해 특정 DB에 대한 접근이 안될 때 여러 DB의 동기화 상태를 유자하고(일관성) 
(2) 분할 내성을 지키는 경우
(3) 그냥 서비스를 멈춰야한다 (가용성 준수 불가)
```

##### Q. 근데 결국 분할 내성을 하는 건 컴퓨터가 망가진 이후에 다른 DB에서 사용키 위함인데 애초에 분할 내성을 지키려면 일관성을 잃을 수 밖에 없지 않나?


<br>

#### [CAP에서의 의사결정 기준]
> a. 은행같이 데이터 일관성이 중요할 때
```
가용성을 준수하지 못하더라도 일관성과 분할 내성을 준수함이 옳다.
```

> b. - 그러게 .. 다 중요해보이는데
```
약간의 데이터 불일치 문제가 있더라도 
```



## 2. 도메인 주도 설계 (DDD)에 대해 알려주세요
- 해결하고자 하는 특정 문제를 '도메인'이라고 표현하고 이를 가장 중요하게 고민해서 결론을 낸 다음 그 뒤로 기술적인 다른 것들을 붙여 나가는 방법.
```
- 개발자 뿐 아니라 이 작업에 연관된 사람들과 공통적으로 이해할 수 있는 유비쿼터스 언어
- 여러개의 레이어드 아키텍처를 두어 체계적으로 관리
- 에그리거트라는 개념으로 각 영역을 분리하고 해당 영역에 대한 접근 애그리거트 루트를 통해서만 가능토록함
- 주로 도메인은 엔터티를 사용하고 애그리거트 루트로 사용, 연결된 애그리거트들은 값 객체등도 많이 사용된다.
```



## 3. 테스트 주도 설계 (TDD)에 대해 알려주세요
- 구현을 먼저 하는게 아닌 테스트를 먼저 작성하고 그 테스트를 성공케 하는 걸 작업의 완료로 보자는 패러다임입니다!
```
장점: 단순히 개발에 집중하는 게 아닌 테스트 해야 하는 부분을 고민해볼 수 있고 테스트를 진행하면서 자연스럽게 객체지향적이지 못한 설계를 확인할 수 있다.
단점: 난이도가 있다.
```



## 4. 소프트웨어 테스팅: 단위/통합/시스템/인수/회귀에 대해 알려주세요

> 1. 단위 테스팅 (Unit Testing):

```
방법: 개발자들은 코드의 가장 작은 단위, 예를 들어 함수나 메소드를 대상으로 테스트를 합니다. 이를 위해 자동화된 테스트 스크립트를 작성하는데, 일반적으로 JUnit, NUnit, 또는 pytest 같은 테스팅 프레임워크를 사용합니다. 각 함수가 올바르게 입력을 받아서 예상된 출력을 내놓는지 확인합니다.
예시: 만약 "덧셈" 함수가 있다면, 입력으로 2와 3을 주었을 때, 이 함수가 5를 반환하는지 테스트합니다.
```

> 2. 통합 테스팅 (Integration Testing):

```
방법: 여러 단위가 통합된 후 이들이 서로 잘 작동하는지 확인합니다. 이 테스트는 보통 크게 두 가지 접근법인 'Big Bang' 방식과 '점진적 통합' 방식으로 나뉩니다. 점진적 통합은 다시 'Top-down', 'Bottom-up', 또는 'Sandwich' 방식으로 세분화될 수 있습니다. 각 방식은 통합의 순서와 방법에 차이가 있습니다.
예시: "사용자 로그인" 기능을 테스트할 때, 데이터베이스에서 사용자 정보를 조회하고, 사용자 인증을 처리하는 함수들이 올바르게 협력하는지 확인합니다.
```

> 3. 시스템 테스팅 (System Testing):

```
방법: 전체 시스템이나 애플리케이션이 최종 사용 환경에서 제대로 동작하는지 확인하기 위해 실시합니다. 이 테스트는 소프트웨어뿐만 아니라 하드웨어와의 상호 작용을 포함한 전반적인 기능을 검사합니다. 자동화된 테스트 케이스 또는 수동 테스트를 통해 수행될 수 있습니다.
예시: 웹 애플리케이션이 다양한 브라우저와 운영 체제에서 제대로 작동하는지 확인합니다.
```

> 4. 인수 테스팅 (Acceptance Testing):

```
방법: 실제 사용자 또는 고객이 참여하여 소프트웨어가 사용자의 요구사항을 만족하는지 평가합니다. 이 단계에서는 '알파 테스트'와 '베타 테스트'와 같은 접근 방식이 사용될 수 있습니다. 사용자는 일상적인 업무에 소프트웨어를 사용해보고 피드백을 제공합니다.
예시: 신규 출시될 쇼핑 앱을 소수의 실제 고객이 사용해보고, 주문부터 배송까지의 과정에서 문제가 없는지 확인합니다.
```

> 5. 회귀 테스팅 (Regression Testing):

```
방법: 코드의 변경이 있을 때마다 이전에 작성된 테스트 케이스를 다시 실행하여 변경으로 인해 발생할 수 있는 문제들을 찾아냅니다. 이 테스트는 일반적으로 자동화되어 있어, 코드를 변경할 때마다 자동으로 실행되도록 설정됩니다.
예시: 새로운 기능을 추가한 후, 이전에 잘 작동하던 로그인, 검색, 결제 기능들이 여전히 잘 작동하는지 자동화된 테스트를 통해 확인합니다.
```


## 5. RabbitMQ와 카프카
- 
```

```

--
